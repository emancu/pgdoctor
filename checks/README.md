# PGDoctor Checks

Each check is self-contained in its own directory with everything it needs: SQL queries, implementation, tests, and documentation.

## Directory Structure

```
db/                      # Shared generated code (all checks)
├── db.go                   # Generated by sqlc (don't edit)
├── models.go               # Generated by sqlc (don't edit)
└── query.sql.go            # Generated by sqlc (don't edit)
checks/
├── invalidindexes/
│   ├── query.sql          # SQL query with sqlc annotations
│   ├── check.go           # Check implementation + Metadata()
│   └── check_test.go      # Unit tests
├── pgversion/
│   ├── query.sql
│   ├── check.go
│   └── check_test.go
├── ...
```

**Note**: Generated database code lives in `db/`, NOT in individual check directories. All checks share this generated code.

## Key Principles

1. **Self-Contained Logic** - Each check directory contains its specific implementation
2. **Metadata Lives With Check** - CLI discovers checks via `Metadata()` function
3. **SQL Embedded** - SQL queries are embedded via `//go:embed` and included in CheckMetadata
4. **Shared Generated Code** - All checks use generated code from `db/`
5. **Independent Execution** - Checks run independently, no dependencies between them
6. **Simple Structure** - SQL → Generate → Implement → Test

## Check Interface

Each check implements the `check.Checker` interface:

```go
type Checker interface {
    Metadata() CheckMetadata
    Check(context.Context) (*Report, error)
}
```

## Adding a New Check

### 1. Create Directory
```bash
mkdir checks/mycheck
```

### 2. Add SQL Query
Create `checks/mycheck/query.sql`:

```sql
-- name: MyQuery :many
SELECT column1, column2
FROM my_table
WHERE condition = true;
```

### 3. Update sqlc Configuration
Add your check to `sqlc.yaml`:

Add your check to the `queries` list in `sqlc.yaml`:

```yaml
queries:
  - "checks/mycheck"
```

### 4. Generate Database Code
```bash
sqlc generate
```

This generates query methods in `db/` that you'll use in your check implementation.

### 5. Implement Check
Create `checks/mycheck/check.go`:

```go
package mycheck

import (
    "context"
    _ "embed"
    "fmt"

    "github.com/emancu/pgdoctor/check"
)

//go:embed query.sql
var querySQL string

type checker struct {
    queryer MyQueryQueries
}

type MyQueryQueries interface {
    MyQuery(context.Context) ([]MyQueryRow, error)
}

// Metadata returns the check's metadata for discovery and documentation.
func Metadata() check.CheckMetadata {
    return check.CheckMetadata{
        Category:    check.CategoryConfigs,
        CheckID:     "my-check",
        Name:        "My Check",
        Description: "One-line summary of what this validates",
        SQL:         querySQL,
    }
}

// New creates a new checker.
func New(queryer MyQueryQueries) check.Checker {
    return &checker{
        queryer: queryer,
    }
}

// Metadata implements check.Checker.
func (c *checker) Metadata() check.CheckMetadata {
    return Metadata()
}

func (c *checker) Check(ctx context.Context) (*check.Report, error) {
    report := check.NewReport(Metadata())

    rows, err := c.queryer.MyQuery(ctx)
    if err != nil {
        return nil, fmt.Errorf("running %s/%s: %w", report.Category, report.CheckID, err)
    }

    if len(rows) == 0 {
        report.AddFinding(check.Finding{
            ID:       report.CheckID,
            Name:     report.Name,
            Severity: check.SeverityOK,
        })
        return report, nil
    }

    // Add findings for issues
    report.AddFinding(check.Finding{
        ID:           "subcheck-id",
        Name:         "Subcheck Name",
        Severity:     check.SeverityFail,
        Details:      "What's wrong",
        Prescription: "How to fix it",
    })

    return report, nil
}
```

**Key patterns:**
- Embed SQL with `//go:embed query.sql`
- Use `check.NewReport(Metadata())` to create reports
- Access check info via promoted fields: `report.CheckID`, `report.Name`, `report.Category`
- Always report `SeverityOK` when no issues found

### 6. Write Tests
Create `checks/mycheck/check_test.go`:

```go
func TestMyCheck(t *testing.T) {
    tests := []struct {
        name     string
        data     []MyQueryRow
        severity check.Severity
    }{
        {
            name:     "all good",
            data:     []MyQueryRow{},
            severity: check.SeverityOK,
        },
        {
            name:     "issue found",
            data:     []MyQueryRow{{Column1: "bad"}},
            severity: check.SeverityFail,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            queryer := &mockQueryer{data: tt.data}
            checker := New(queryer)

            report, err := checker.Check(context.Background())

            require.NoError(t, err)
            assert.Equal(t, tt.severity, report.Severity)
        })
    }
}
```

### 7. Register Check

Run the code generator to auto-discover your new check:

```bash
go generate ./...
```

This scans `checks/` for packages with a `Metadata()` function and regenerates `checks.go`.

### 8. Verify
```bash
go build -o pgdoctor ./cmd/pgdoctor
./pgdoctor list                        # Should show your check
./pgdoctor explain my-check            # Should show SQL and metadata
```

## Running Checks

Checks run via the CLI:

```bash
# Run all checks
pgdoctor run --dsn "postgres://user:pass@host:5432/db"

# Run with filters
pgdoctor run --dsn "..." --only pg-version,my-check
pgdoctor run --dsn "..." --ignore vacuum

# Hide passing checks
pgdoctor run --dsn "..." --hide-passing

# Show details
pgdoctor run --dsn "..." --detail verbose

# Show debug info including SQL
pgdoctor run --dsn "..." --detail debug

# List available checks
pgdoctor list

# Get detailed documentation
pgdoctor explain my-check
```

## Testing

Write table-driven tests using the Checker interface:

```go
func TestMyCheck(t *testing.T) {
    t.Parallel()

    tests := []struct {
        name     string
        data     []MyQueryRow
        wantErr  bool
        severity check.Severity
        details  string
    }{
        {
            name:     "optimal configuration",
            data:     []MyQueryRow{},
            severity: check.SeverityOK,
        },
        {
            name:     "issue detected",
            data:     []MyQueryRow{{Value: "bad"}},
            severity: check.SeverityFail,
            details:  "expected text in details",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            queryer := &mockQueryer{data: tt.data}
            checker := New(queryer)

            report, err := checker.Check(context.Background())

            if tt.wantErr {
                require.Error(t, err)
                return
            }

            require.NoError(t, err)
            assert.Equal(t, tt.severity, report.Severity)

            if tt.details != "" {
                require.NotEmpty(t, report.Results)
                assert.Contains(t, report.Results[0].Details, tt.details)
            }
        })
    }
}
```

## Naming Conventions

- **CheckID**: kebab-case with hyphens (`my-check`, `invalid-indexes`)
- **Directory**: single word (`mycheck`, `invalidindexes`)
- **Package**: same as directory
- **Finding ID**: kebab-case for subchecks (`index-timestamp`, `single-table`)

## Common Patterns

### Single Result Check
If your check has only one validation:

```go
report.AddFinding(check.Finding{
    ID:       report.CheckID,  // Same as check
    Name:     report.Name,
    Severity: check.SeverityOK,
})
```

### Multiple Subchecks
If your check has multiple validations:

```go
report.AddFinding(check.Finding{
    ID:           "subcheck-1",
    Name:         "First Validation",
    Severity:     check.SeverityFail,
    Details:      "What's wrong with first validation",
    Prescription: "How to fix first validation",
})

report.AddFinding(check.Finding{
    ID:           "subcheck-2",
    Name:         "Second Validation",
    Severity:     check.SeverityWarn,
    Details:      "What's wrong with second validation",
    Prescription: "How to fix second validation",
})
```

### Tabular Data
For checks that output structured data:

```go
report.AddFinding(check.Finding{
    ID:       "config-check",
    Name:     "Configuration Values",
    Severity: check.SeverityFail,
    Details:  fmt.Sprintf("Found %d issues", len(issues)),
    Table: &check.Table{
        Headers: []string{"Parameter", "Current", "Expected", "Status"},
        Rows: []check.TableRow{
            {
                Cells:    []string{"timeout", "0ms", "500-5000ms", "Too low"},
                Severity: check.SeverityFail,
            },
        },
    },
    Prescription: "How to fix these issues",
})
```

## CLI Output Format

The CLI displays checks grouped by category:

```
Database Health Check: production/checkout
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

═══════════════════════════════ CONFIGS ════════════════════════════════

[FAIL] PostgreSQL Session Configs (session-settings)
  Found 4 configuration issue(s)

  Role    Parameter        Current   Expected    Status
  ──────  ───────────────  ────────  ──────────  ────────
  app_ro  statement_timeout  600000ms  500-5000ms  Too high

    How to fix:
      Configure role settings using ALTER ROLE...

[INFO] PostgreSQL Version (pg-version)

═══════════════════════════════ INDEXES ════════════════════════════════

[WARN] Invalid Indexes (invalid-indexes)

  [WARN] Index validation (invalid-index)
    Found 2 invalid indexes that need rebuilding

    How to fix:
      Rebuild indexes with REINDEX CONCURRENTLY...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Summary: 1 failure, 1 warning, 1 passed
```

**Key formatting rules:**
- Category headers only shown if category has visible checks
- Checks: `[Severity] Name (check-id)`
- Subchecks: indented 2 spaces with `[Severity] Name (finding-id)`
- Details: indented 4 spaces
- WARN/FAIL lines fully colored for emphasis, OK only colors the label
- Subchecks sorted ascending by severity (OK first, FAIL last)
